<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Rest on occasional posts about technology </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://localhost:1313/categories/rest/index.xml</link>
    <language>en-us</language>
    
    
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    <item>
      <title>Pyramid and Traversal with a RESTful interface</title>
      <link>http://localhost:1313/pyramid-bad-traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/pyramid-bad-traversal/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;UPDATE (2011-08-05)&lt;/h2&gt;

&lt;p&gt;Please use caution when reading this post. A lot of the approach and implementation here is flawed. I am keeping the post up for historical purposes, but I am currently working on a follow up post that has a much better and proper implementation of traversal for SQLalchemy models. The practice of not returning real instances as traversal expects and tightly coupling the models to the traversal method is something that is less than desirable and will lead to more pain than gain long term. That being said, some of the approaches here are a good way to learn about traversal and how one might want to use it with their data model.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Original Post&lt;/h2&gt;

&lt;p&gt;When Pyramid was first being developed I was intrigued by the idea that I could create context aware views and use a host of methods to check permissions on those contexts, generate URLs based off those contexts, and auto-magically call the view required based on the context and the requested resource path.&lt;/p&gt;

&lt;p&gt;So one of my first experiments with Pyramid was to implement proper resource urls for contexts in a RESTful fashion. Eventually I plan to do this for the entire collection as well, but for now all I need is the context level RESTful interface. The goal of which is to have URLs that go something like this.&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt; /resource/id (GET) - default view of the resource &lt;/li&gt;
    &lt;li&gt; /resource/id/edit (GET) - the form that allows you to edit the resource &lt;/li&gt;
    &lt;li&gt; /resource/id/create (GET) - the form that allows you to edit the resource &lt;/li&gt;
    &lt;li&gt; /resource/id (PUT) - updates &lt;/li&gt;
    &lt;li&gt; /resource/id (POST) - create &lt;/li&gt;
    &lt;li&gt; /resource/id (DELETE) - delete &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This ends up being pretty damn simple with Pyramid and Traversal and for those of you new to traversal or even those who aren&amp;rsquo;t, I highly recommend reading the &lt;a href=&#34;http://docs.pylonsproject.org/projects/pyramid/dev/narr/muchadoabouttraversal.html&#34;&gt;Much Ado About Traversal&lt;/a&gt; chapter in the Pyramid documentation. Also on a side note all of the snippets from this post are part of a real project called &lt;a href=&#34;https://sourceforge.net/p/stockpot/code&#34;&gt;Stockpot&lt;/a&gt; and the code is freely available via SourceForge.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;My Root&lt;/h2&gt;

&lt;p&gt;So first step for me was to design my Root object. This is the really the foundation for traversal and determines what resources it will be able to find and how to interact with them once it finds them. My Root object is simple and looks like this.&lt;/p&gt;

&lt;pre class=&#34;brush: py&#34;&gt;
def _owned(obj, name, parent):
    obj.__name__ = name
    obj.__parent__ = parent
    return obj
    
class Root(dict):
    __name__ = None
    __parent__ = None
    #
    def __init__(self, request):
        dict.__init__(self)
        self.request = request
        self[&#39;user&#39;] = _owned(User, &#39;user&#39;, self)
&lt;/pre&gt;

&lt;p&gt;This is pretty straightforward. We create a user entry point for the first call to &lt;strong&gt;getitem&lt;/strong&gt; and return the User model with a name of user and the Root object as the parent.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;My Model&lt;/h2&gt;

&lt;p&gt;For my Root object to really do anything useful our model class needs to do some work so that when the traversal algorithm calls &lt;strong&gt;getitem&lt;/strong&gt; on our User model it actually gets something useful back. I&amp;rsquo;ve done this using a base class for my declarative_base call.&lt;/p&gt;

&lt;pre class=&#34;brush: py&#34;&gt;
class StockpotBase(object):
    @classmethod
    def __getitem__(cls, k):
        try:
            result =  DBSession().query(cls).filter_by(id=k).one()
            result.__parent__ = result
            result.__name__ = str(k)
            return result
        except NoResultFound, e:
            raise KeyError
    @classmethod
    def __len__(cls):
        return DBSession().query(cls).count()    
    @classmethod
    def __iter__(cls):
        return (x for x in DBSession().query(cls))
        
Base = declarative_base(cls=StockpotBase)

class User(Base):
    __tablename__ = &#39;users&#39;
    __name__ = &#39;user&#39;
    #
    def __init__(self, email, password=None, display_name=None):
        self.email = email
        self.password = password
        self.display_name = display_name
    #
    id = Column(Integer, primary_key=True)
    email = Column(String, nullable=False, unique=True)
    password = Column(String, nullable=True)
    display_name = Column(String, nullable=True)
    user_groups = relation(Group, backref=&#39;user&#39;, secondary=groups)
    groups = association_proxy(&#39;user_groups&#39;, &#39;name&#39;, creator=Group.group_creator)
    recipes = relation(Recipe, backref=&#39;user&#39;)
    #
    def __str__(self):
        return &#39;User(id={0}, email={1}, groups={2})&#39;.format(self.id, self.email, self.groups)

    def __repr__(self):
        return self.__str__()
&lt;/pre&gt;

&lt;p&gt;So that is a pretty big chunk of code so let me go through what is happening, it is rather simple. I&amp;rsquo;ve created StockpotBase which has the methods our traversal algorithm is going to want. I&amp;rsquo;ve used that as the cls for my declarative_base call so that any class that I create that inherits from Base will have all of the proper methods needed.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;getitem&lt;/strong&gt; itself ensures that the parent is set to the generic user class and the name of the class is set to the primary key. This is important later when we start using resource_url() to generate links for us in our templates, if you consider that the urls will be generated with the pattern of /&lt;strong&gt;parent&lt;/strong&gt;.&lt;strong&gt;name&lt;/strong&gt;/context.&lt;strong&gt;name&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;My Views&lt;/h2&gt;

&lt;p&gt;With the Root object setup and our model &amp;ldquo;traversal enabled&amp;rdquo;, we can look at how the views for this will be setup. I personally like to use the config.scan(&amp;lsquo;stockpot.views&amp;rsquo;) helper and use the @view_config decorator for my views. I find it cleaner and easier to to have the view_config right with the actually def.&lt;/p&gt;

&lt;pre class=&#34;brush: py&#34;&gt;
# RESOURCE_URL = /user/id
@view_config(context=User, renderer=&#39;user/view.mako&#39;)
def get(request):
    return dict(user=request.context)
    
# RESOURCE_URL = /user/id/edit
@view_config(name=&#39;edit&#39;, context=User, renderer=&#39;user/edit.mako&#39;)
def edit(request):
    return dict(user=request.context)
&lt;/pre&gt;

&lt;p&gt;So here is the default GET view. It allows anyone to use this view, but I will have a blog post about permissions with ACL and traversal later, and it uses the renderer of my user/view.mako template. Then we have the edit view which requires User:edit permissions and uses the edit.mako template. Pretty simple. Next we have the first of the JSON views (they don&amp;rsquo;t have to be JSON).&lt;/p&gt;

&lt;pre class=&#34;brush: py&#34;&gt;
@view_config(context=User, request_method=&#39;PUT&#39;, xhr=True, renderer=&#39;json&#39;)
def put(request):
    user = request.context
    return dict(method=&#39;PUT&#39;, user_id=user.id, email=user.email)
&lt;/pre&gt;

&lt;p&gt;And the mako template jQuery for this might look something like this&lt;/p&gt;

&lt;p&gt;$$code(lang=javascript, linenums=True)
$(document).ready(function() {
    $(&amp;lsquo;#put&amp;rsquo;).click(function() {
        $.ajax({
            url: &amp;lsquo;${request.resource_url(user)}&amp;lsquo;,
            type: &amp;lsquo;PUT&amp;rsquo;,
            context: document.body,
            dataType: &amp;lsquo;json&amp;rsquo;,
            success: function(data) {
                console.log(data);
                alert(&amp;lsquo;done&amp;rsquo;);
            }
        });
    });
});
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;And that is it. You would repeat the same view pattern for request_method POST and request_method DELETE and you would have RESTful API in to your resources/models in a very clean fashion.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;What Happens&lt;/h2&gt;

&lt;p&gt;When a user visits the resource url a simple series of calls to &lt;strong&gt;getitem&lt;/strong&gt; happens. The Root (/) object is called with &amp;lsquo;user&amp;rsquo;. A User object with the name of &amp;lsquo;user&amp;rsquo; and the parent of Root is returned. The User class has it&amp;rsquo;s &lt;strong&gt;getitem&lt;/strong&gt; called and uses the DBSession to lookup a user based on the key given. For example /user/1 (Root / User / k) would result in &amp;lsquo;1&amp;rsquo; being passed to the user objects &lt;strong&gt;getitem&lt;/strong&gt; as the key. If it locates the user, it returns the instance and sets the name and parent. If you don&amp;rsquo;t set the name when you call resource_url with the context, the generated URL would look read /user instead of /user/1.&lt;/p&gt;

&lt;p&gt;There is nothing after the 1 so it looks for a generic unnamed view that handles the User context. In our case, our get method. When you add on edit, /user/1/edit it works in the same fashion, but when it tries to call &lt;strong&gt;getitem&lt;/strong&gt; a second time on the User instance it will throw a key error which tells Pyramid that I am looking for a view named edit with the context of User. This traversal works the same way for the JSON calls as well.&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Feedback&lt;/h2&gt;

&lt;p&gt;I don&amp;rsquo;t like the fact that there are extra DB calls here, but it is a trade off. Even the /user/1/edit has to make two database calls to get the KeyError and review the proper view, but as a side-effect I can do something like /user/1/collection/1 and get the specific item of the collection owned by the user. That extends to edits as well &amp;hellip; /user/1/collection/1/edit. Overall I like how this pattern has evolved in my application, but would appreciate any feedback or suggested improvements to what I&amp;rsquo;ve done so far.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RESTful Pylons</title>
      <link>http://localhost:1313/restful-pylons/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/restful-pylons/</guid>
      <description>&lt;p&gt;In the process of creating a new web service for the purpose of allowing external applications to communicate with my site, I realized I was going against the grain and making things harder for myself than they had to be.&lt;/p&gt;

&lt;p&gt;Pylons and Python make it so easy to just start pounding out code you can be half way through an implementation before you realize it is broke, or reinventing something that already exists, or just plain sucks.&lt;/p&gt;

&lt;p&gt;So, I do a commit to my local repository, Ctrl+A and hit delete. Lets try this over. I take a step back and look at what we need to do.&lt;/p&gt;

&lt;p&gt;We have a Kill object. This is a representation of a Ship a Pilot and another or many other Ship(s) and Pilot(s) who destroyed this ship and where and why the did it. That is the verbose text version of a kill. My remote service wants to perform CRUD operations on this model. I have all this implemented already, the controllers for my views do all of this .. so why not copy them and just give them some tweaks and expose these new methods under a poorly named controller? Great idea! .. Not so much.&lt;/p&gt;

&lt;p&gt;So, the solution, create a new &lt;a href=&#34;http://en.wikipedia.org/wiki/Representational_State_Transfer&#34;&gt;REST&lt;/a&gt; controller in Pylons. Pylons does all the heavy lifting for you with a simple command, the only thing you need to do is update your routing.py to include the new resource. You create the REST controller just like you would a normal, but using restcontroller instead of controller and adding and extra variable for the name of the resource. Usually a plural of your model.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;# paster restcontroller kill kills
Creating wayne\qkb\controllers\kills.py
Creating wayne\qkb\tests\functional\test_kills.py
To create the appropriate RESTful mapping, add a map statement to your
config/routing.py file near the top like this:
map.resource(&amp;lsquo;kill&amp;rsquo;, &amp;lsquo;kills&amp;rsquo;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Ok, so what did that give us? Well, basically everthing we need. If you pop open kills.py in your controllers, you&amp;rsquo;ll see it already has sketched out the methods you&amp;rsquo;ll be implementing for your kills resource and also gives you a reminder to update your routing.py&lt;/p&gt;

&lt;p&gt;From here, it is rather simple. Just implement the responses in each of the methods that your external application will need. Don&amp;rsquo;t forget to change the formats from HTML if you aren&amp;rsquo;t going to be sending back to a browser or HTML parser. Example of the index implementation. Which would be called using a GET to /kills under the default routing.
[sourcecode language=&amp;ldquo;python&amp;rdquo;]
def index(self, format=&amp;lsquo;xml&amp;rsquo;):
    &amp;ldquo;&amp;rdquo;&amp;ldquo;GET /kills: All items in the collection.&amp;ldquo;&amp;rdquo;&amp;rdquo;
    # url_for(&amp;lsquo;kills&amp;rsquo;)
    kill_q = meta.Session.query(model.Kill)
    c.kills = kill_q.all()
    return render(&amp;lsquo;/derived/kills/list.xml&amp;rsquo;)
[/sourcecode]&lt;/p&gt;

&lt;p&gt;Following this pattern, I implement the rest of my resource methods and end up with a fully functional resource with in minutes. Not only was this faster to live than modifying the methods that were designed for handling posts from the view layer, it also creates a much cleaner exposure of the Kill model to external services. Heres the implementation of create, which is /kills with the POST method.&lt;/p&gt;

&lt;p&gt;[sourcecode language=&amp;ldquo;python&amp;rdquo;]
def create(self):
    &amp;ldquo;&amp;rdquo;&amp;ldquo;POST /kills: Create a new item.&amp;ldquo;&amp;rdquo;&amp;rdquo;
    # url_for(&amp;lsquo;kills&amp;rsquo;)
    try:
       params = model.forms.schema.KillSchema.\
                to_python(request.params)
       kill = model.Kill(**params)
       meta.Session.save(kill)
       meta.Session.commit()
       c.killid = kill.id
       return render(&amp;lsquo;/derived/kill/create.xml&amp;rsquo;)
    except formencode.Invalid, e:
       c.errors = e.errors_dict() or {}
       return render(&amp;lsquo;/derived/kill/error.xml&amp;rsquo;)
[/sourcecode]&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>