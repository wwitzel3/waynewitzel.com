<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>C on occasional posts about technology </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://localhost:1313/categories/c/index.xml</link>
    <language>en-us</language>
    
    
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    <item>
      <title>Boost Python, Threads, and Releasing the GIL</title>
      <link>http://localhost:1313/python-boost-gil/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/python-boost-gil/</guid>
      <description>&lt;p&gt;
After Beazley&#39;s talk at PyCon &amp;quot;Understanding the Python GIL&amp;quot; I released I had never done any work that released the GIL, spawned threads, did some work, and then restored the GIL. So I wanted to see if I could so something like that with Boost::Python and Boost::Thread and the type of performance I&#39;d get from it with an empty while loop as the baseline. So I hacked up some quick and dirty C++ code and quick bit of runable Python to test out the resulting module and away I went. Below are the code snippets, links to bitbucket, and the results of the Python runable.

&lt;pre class=&#34;brush: cpp&#34;&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;boost/shared_ptr.hpp&gt;
#include &lt;boost/thread.hpp&gt;
#include &lt;boost/python.hpp&gt;

class ScopedGILRelease {
public:
    inline ScopedGILRelease() { m_thread_state = PyEval_SaveThread(); }
    inline ~ScopedGILRelease() {
        PyEval_RestoreThread(m_thread_state);
        m_thread_state = NULL;
    }
private:
    PyThreadState* m_thread_state;
};

void loop(long count)
{
    while (count != 0) {
        count -= 1;
    }
    return;
}

void nogil(int threads, long count)
{
    if (threads &lt;= 0 || count &lt;= 0)
        return;
    
    ScopedGILRelease release_gil = ScopedGILRelease();
    long thread_count = (long)ceil(count / threads);
    
    std::vector&lt;boost::shared_ptr&lt;boost::thread&gt; &gt; v_threads;
    for (int i=0; i != threads; i++) {
        boost::shared_ptr&lt;boost::thread&gt;
        m_thread = boost::shared_ptr&lt;boost::thread&gt;(
            new boost::thread(
                boost::bind(loop,thread_count)
            )
        );
        v_threads.push_back(m_thread);
    }
    
    for (int i=0; i != v_threads.size(); i++)
        v_threads[i]-&gt;join();
    
    return;
}

BOOST_PYTHON_MODULE(nogil)
{
    using namespace boost::python;
    def(&#34;nogil&#34;, nogil);
}
&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;
Then I used the following Python script to run some quick tests.

&lt;pre class=&#34;brush: py&#34;&gt;
import time
import nogil

def timer(func):
    def wrapper(*arg):
        t1 = time.time()
        func(*arg)
        t2 = time.time()
        print &#34;%s took %0.3f ms&#34; % (func.func_name, (t2-t1)*1000.0)
    return wrapper

@timer
def loopone():
    count = 5000000
    while count != 0:
        count -= 1

@timer
def looptwo():
    count = 5000000
    nogil.nogil(1,count)

@timer
def loopthree():
    count = 5000000
    nogil.nogil(2,count)

@timer
def loopfour():
    count = 5000000
    nogil.nogil(4,count)
    
@timer
def loopfive():
    count = 5000000
    nogil.nogil(6,count)
        
def main():
    loopone()
    looptwo()
    loopthree()
    loopfour()
    loopfive()
    
if __name__ == &#39;__main__&#39;:
    main()
&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;
The results I got were quite interesting and very consistent on my MacBook Pro. I ran the script about 1,000 times and got roughly the same results every time.

&lt;pre class=&#34;brush: bash&#34;&gt;
loopone took 364.159 ms (pure python)
looptwo took 15.295 ms (c++, no GIL, single thread)
loopthree took 7.763 ms (c++, no GIL, two threads)
loopfour took 8.119 ms (c++, no GIL, four threads)
loopfive took 11.102 ms (c++, no GIL, six threads)
&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;Anyway, that&amp;rsquo;s all really. Nothing profound here, no super insightful ending. Just hey look and stuff is faster and I might use this. All the code for this is available in my bitbucket repo. &lt;a href=&#34;http://bitbucket.org/wwitzel3/code/src/tip/nogil/&#34;&gt;http://bitbucket.org/wwitzel3/code/src/tip/nogil/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You will require Boost Library including Boost Python and Boost Thread as well as Python libraries and includes to build this. For boost, bjam &amp;ndash;with-python &amp;ndash;with-thread variant=release toolset=gcc is all I did on my Mac. Then I added the resulting lib&amp;rsquo;s as Framework dependencies in Xcode along with the Python.framework.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dynamic and static typing with unit tests.</title>
      <link>http://localhost:1313/tests-dynamic-static/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/tests-dynamic-static/</guid>
      <description>&lt;p&gt;There is an on going discussion at the office with a team member who refuses to use dynamic languages. Claiming that most of his errors are typographical errors and they are caught by the compiler. So for him, since these errors are not caught until runtime, he throws and entire group of languages out the window. He also claims that to ensure that same level of checking with a dynamic language you would have to create more unit tests than normal to prevent introducing unhandled runtime exceptions.&lt;/p&gt;

&lt;p&gt;So I decided to do a little test over the weekend. I created a very simple Number class in Python and C++. Using the exact same TDD development process, I implemented some very basic operations including division, addition, subtraction, etc&amp;hellip; I ended up with 12 tests. The exact same tests for both the C++ and Python implementation resulting in 100% of the executation path being covered. I decided that the compliation (in case of C++) and passing of the tests determined a success.&lt;/p&gt;

&lt;p&gt;Then went back and inserted common typographical errors. Mistypes, extra = signs, not enough = signs, miseplled_varaibles, etc&amp;hellip; The end result was I was unable to get my unit tests passing while introducing syntax that would induce an unhandled runtime exception in Python. Granted, in C++ the compiler did catch a lot of things for me, but the point here is I didn&amp;rsquo;t have to create any extra tests to ensure that same level of confidence in my Python code.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>